# Claude Code Guidelines for QBT Project

## 프로젝트 개요

QBT(Quant BackTest)는 주식 데이터 다운로드 및 백테스팅을 위한 Python CLI 도구입니다.

**주요 기능**:
- Yahoo Finance에서 주식 데이터 다운로드
- 버퍼존 기반 이동평균 전략 백테스트
- 파라미터 그리드 서치
- 레버리지 ETF 시뮬레이션 및 검증
- 인터랙티브 웹 대시보드 (Streamlit + Plotly)

### 핵심 디렉토리 구조

```
quant/
├── scripts/                            # CLI 실행 스크립트 (도메인별 분리)
│   ├── data/
│   │   └── download_data.py            # 데이터 다운로드
│   ├── backtest/
│   │   ├── run_single_backtest.py      # 단일 백테스트
│   │   └── run_grid_search.py          # 그리드 서치
│   └── tqqq/
│       ├── generate_synthetic_tqqq.py  # 합성 레버리지 ETF 생성
│       ├── validate_tqqq_simulation.py # 시뮬레이션 검증
│       ├── generate_tqqq_daily_comparison.py  # 일별 비교 데이터 생성
│       └── streamlit_app.py            # 웹 대시보드 실행
├── src/qbt/                            # 비즈니스 로직 패키지
│   ├── config.py                       # 전역 설정 (경로 상수)
│   ├── backtest/                       # 백테스트 도메인
│   │   ├── config.py                   # 백테스트 전용 설정
│   │   ├── data.py                     # 데이터 로딩/검증
│   │   ├── strategy.py                 # 전략 실행 로직
│   │   ├── metrics.py                  # 성과 지표 계산
│   │   ├── report.py                   # 리포트 생성
│   │   └── exceptions.py               # 커스텀 예외
│   ├── synth/                          # 합성 데이터 생성 도메인
│   │   └── leveraged_etf.py            # 레버리지 ETF 시뮬레이션
│   ├── visualization/                  # 시각화 도메인
│   │   └── tqqq_dashboard.py           # 대시보드 컴포넌트
│   └── utils/                          # 유틸리티
│       ├── logger.py                   # 로깅 설정
│       ├── formatting.py               # 테이블 출력 포맷팅
│       └── data_loader.py              # 데이터 로딩 공통 함수
├── data/raw/                           # CSV 데이터 저장소
├── results/                            # 분석 결과 저장소
└── pyproject.toml                      # Poetry 프로젝트 설정
```

### 기술 스택

- **Python**: 3.10 이상 (Union 타입 구문 `str | None` 사용)
- **패키지 관리**: Poetry
- **데이터 처리**: pandas
- **데이터 소스**: Yahoo Finance (yfinance)
- **시각화**: Plotly (인터랙티브 차트)
- **웹 프레임워크**: Streamlit (대시보드)
- **코드 품질**: Black (포맷터), Ruff (린터)

## 아키텍처 설계

### CLI 계층 구조

QBT는 단순한 2계층 구조를 사용합니다:

#### CLI Layer (scripts/)
- **로거 초기화**: 환경 변수를 읽어 로거 설정
- **커맨드 파싱**: argparse로 사용자 입력 처리
- **비즈니스 로직 호출**: 공통 유틸리티를 통해 데이터 로딩 및 검증
- **최종 예외 처리**: try-except로 모든 예외를 캐치하여 사용자 친화적 에러 메시지 출력
- **종료 코드 반환**: 성공 시 0, 실패 시 1

#### Business Logic Layer (src/qbt/)
- **핵심 기능 수행**: 데이터 로딩, 전략 실행, 지표 계산 등
- **데이터 검증**: 입력값 유효성 검사
- **예외 재발생**: 에러 발생 시 로깅 없이 `raise`로 호출자에게 예외 전파
- **명시적 예외**: 가능한 경우 구체적인 예외 타입 사용

**중요**: 비즈니스 로직에서는 ERROR 레벨 로그를 남기지 않습니다. 에러 로깅은 CLI Layer에서만 수행하여 중복을 방지합니다.

### 패키지 구조

- **패키지 형식**: `src/qbt/domain/module.py`로 도메인별 구분
- **모듈 분리**: 기능별로 모듈 분리 (데이터, 전략, 지표, 리포트)
- **CLI 로직**: `scripts/` 디렉토리에 독립 스크립트로 위치
- **비즈니스 로직**: `src/qbt/` 패키지 내부에 위치

### 도메인 모듈 구조

#### 백테스트 도메인 (backtest/)
- **config.py**: 백테스트 전용 전략 파라미터 및 검증 임계값
- **data.py**: 데이터 로딩 및 검증
- **strategy.py**: 전략 실행 (버퍼존 전략, 그리드 서치)
- **metrics.py**: 성과 지표 계산 (수익률, CAGR, MDD 등)
- **report.py**: 결과 저장 및 리포트 생성
- **exceptions.py**: 커스텀 예외 정의

#### 합성 데이터 생성 도메인 (synth/)
- **leveraged_etf.py**: 레버리지 ETF 시뮬레이션 및 검증 로직

#### 시각화 도메인 (visualization/)
- **tqqq_dashboard.py**: 대시보드 차트 컴포넌트 (Plotly 기반)

## 설정 관리

QBT 프로젝트는 2계층 config 구조를 사용합니다.

### 전역 Config (`src/qbt/config.py`)

모든 도메인에서 공통으로 사용하는 경로 상수를 정의합니다.

**포함 항목**:
- 디렉토리 경로 (`DATA_DIR`, `RESULTS_DIR`)
- 데이터 파일 경로 (`QQQ_DATA_PATH`, `TQQQ_DATA_PATH`, `FFR_DATA_PATH` 등)
- 결과 파일 경로 (`GRID_RESULTS_PATH`, `TQQQ_VALIDATION_PATH` 등)

### 도메인별 Config

도메인 특화 설정은 각 도메인의 `config.py`에 정의합니다.

#### 백테스트 Config (`src/qbt/backtest/config.py`)

백테스트 전략 파라미터와 검증 임계값을 정의합니다.

**포함 항목**:
- 데이터 검증 상수 (`REQUIRED_COLUMNS`, `PRICE_CHANGE_THRESHOLD`)
- 거래 비용 상수 (`SLIPPAGE_RATE`)
- 전략 기본 파라미터 (`DEFAULT_MA_WINDOW`, `DEFAULT_BUFFER_ZONE_PCT` 등)
- 그리드 서치 범위 (`DEFAULT_MA_WINDOW_LIST`, `DEFAULT_BUFFER_ZONE_PCT_LIST` 등)

**설계 원칙**:
- 경로 상수는 전역 config에만 정의
- 도메인별 비즈니스 로직 상수만 도메인 config에 정의
- 상수 중복 금지

## 코딩 규칙

### 테스트 정책

- **테스트 실행 금지**: Claude Code는 테스트를 직접 실행하지 않습니다
- **테스트 작성 가능**: 요청 시 테스트 코드 작성은 가능합니다
- **사용자 책임**: 모든 테스트 실행 및 검증은 사용자가 직접 수행합니다
- **테스트 제안**: 테스트가 필요한 경우 사용자에게 실행을 권장할 수 있습니다

### 코드 포맷팅

- **코드 포맷터**: Black 사용. 모든 Python 코드는 Black 스타일을 따릅니다
- **Black 명령어 직접 실행 금지**: 로컬 또는 CI에서 black 명령어를 수동으로 실행하지 않습니다. 포맷팅은 에디터 자동 포맷팅(Format on Save) 또는 포매터 통합 설정을 통해서만 적용합니다.
- **린터**: Ruff 사용 (pycodestyle, pyflakes, isort, flake8-bugbear, pyupgrade 포함)
- **라인 길이**: 120자
- **타겟 버전**: Python 3.10+

### 네이밍 컨벤션

- **함수**: `snake_case`
- **클래스**: `PascalCase`
- **상수**: `UPPER_SNAKE_CASE`
- **Private 멤버**: `_leading_underscore`

### 타입 힌트

- **필수 적용**: 모든 함수 시그니처에 타입 힌트 작성
- **Python 3.10+ 문법 사용**: `str | None` (Union 타입)

### 문서화

- **Docstring**: 모든 public 함수와 클래스에 Google 스타일 docstring 작성
- **언어**: 한글로 작성 (사용자 대상 프로젝트)
- **필수 항목**: Args, Returns, Raises (해당하는 경우)
- **이모지 예외**: 코드와 주석에서는 이모지를 사용하지 않으나, Streamlit 앱의 사용자 인터페이스에서는 시각적 효과를 위해 제한적으로 사용 가능

### 주석 작성 규칙

- **복잡한 로직**: 여러 단계의 처리 흐름이 있을 경우 넘버링 주석으로 단계별 설명
- **주석 업데이트**: 코드 수정 시 관련 주석도 함께 업데이트하여 불일치 방지
- **일반적 표현 사용**: 구체적 수치 대신 일반적 표현 사용 (예: "5회 재시도" → "임계값 초과 시 재시도")

### 파일 경로 처리

- **pathlib.Path 필수**: 모든 파일 작업에 `pathlib.Path` 사용, 문자열 경로 금지
- **하드코딩 금지**: 프로젝트 루트 기준 상대 경로 사용

### Streamlit 앱 개발

Streamlit 웹 대시보드 개발 시 다음 규칙을 따릅니다:

#### 앱 구조
- **진입점**: 스크립트 디렉토리에 독립 실행 파일 배치
- **비즈니스 로직 분리**: 차트 생성 및 데이터 처리 로직은 시각화 도메인 패키지로 분리
- **단일 페이지**: 현재는 단일 페이지 대시보드로 구성

#### 성능 최적화
- **데이터 캐싱**: 데이터 로딩 함수에 캐싱 데코레이터 적용
- **차트 재사용**: 차트 생성 함수는 순수 함수로 작성하여 재사용성 확보

#### 사용자 경험
- **명확한 안내**: 데이터 파일 누락 시 생성 방법 안내
- **에러 처리**: 파일 누락, 데이터 검증 오류 등을 사용자 친화적 메시지로 표시
- **인터랙티브 차트**: Plotly 차트의 인터랙티브 기능 활용 (확대/축소, 툴팁, 범례 토글)

#### 레이아웃
- **와이드 레이아웃**: 차트 가시성을 위해 와이드 모드 사용
- **섹션 구분**: 헤더와 구분선으로 명확한 섹션 분리
- **메트릭 카드**: 요약 지표는 컬럼 레이아웃으로 배치

### Plotly 차트 작성

Plotly를 사용한 인터랙티브 차트 작성 시 다음 규칙을 따릅니다:

#### 차트 함수 설계
- **순수 함수**: 차트 생성 함수는 DataFrame을 입력받아 Figure 객체를 반환하는 순수 함수로 작성
- **재사용성**: 시각화 도메인 패키지에 배치하여 다른 컨텍스트에서도 재사용 가능하도록 설계
- **타입 힌트**: DataFrame과 Figure 타입 힌트 명시

#### 차트 스타일
- **일관된 색상**: 유사한 데이터는 동일한 색상 팔레트 사용
- **명확한 레전드**: 범례 텍스트는 간결하고 이해하기 쉽게 작성
- **툴팁 커스터마이징**: 호버 템플릿을 사용하여 유용한 정보만 표시

#### 데이터 검증
- **필수 컬럼 체크**: 차트 생성 전 필수 컬럼 존재 여부 검증
- **결측치 처리**: 결측치가 있는 경우 적절히 제거하거나 표시
- **날짜 형식**: 날짜 컬럼은 datetime 타입으로 변환하여 축 포맷팅 일관성 확보

## 도메인별 규칙

### 로깅 정책

#### 로그 레벨

QBT 프로젝트는 **세 가지 로그 레벨만** 사용합니다:

- **DEBUG**: 개발 중 상세 정보 및 디버깅 메시지
  - 데이터 처리 과정
  - 변수 값 확인
  - 함수 실행 흐름
- **WARNING**: 경고성 메시지
  - 잠재적 문제 상황
  - 권장하지 않는 사용법
- **ERROR**: 에러 발생 시 (CLI Layer에서만 사용)
  - 예외 처리
  - 치명적 오류

**INFO 레벨은 사용하지 않습니다.** 일반 정보는 DEBUG로 처리합니다.

#### 로깅 가이드라인

- **메시지는 한글로 작성**: 사용자 대상 프로젝트이므로 한글 사용
- **이모지 사용 금지**: 로그 메시지에 이모지 포함하지 않음
- **간결하고 명확하게**: 불필요한 장황한 설명 지양
- **함수명 자동 포함**: 로그 포맷에 `funcName`이 포함되므로 메시지에 중복 기재 불필요

#### 테이블 형식 로그 출력

정렬된 테이블 형식으로 데이터를 출력할 때는 한글/영문 혼용 시 터미널 폭을 정확히 계산해야 합니다.

**핵심 원칙:**

1. **터미널 폭 계산**: 한글은 2칸, 영문/숫자/기호는 1칸으로 계산
2. **전용 클래스 사용**: 테이블 구조를 정의하고 헤더/데이터/푸터를 일관되게 출력하는 클래스 활용
3. **정렬 방향 지정**: 좌측/우측/중앙 정렬을 명시적으로 지정

**사용 패턴:**

1. 컬럼 정의: 각 컬럼의 이름, 폭, 정렬 방향을 튜플 리스트로 정의
2. 테이블 로거 생성: 정의된 컬럼과 로거 인스턴스로 초기화
3. 데이터 출력: 행 데이터 리스트와 선택적 제목으로 전체 테이블 출력

**개별 포맷팅 함수:**
- 단일 셀을 정렬하는 함수
- 여러 셀을 한 행으로 조합하는 함수
- 일반적으로는 테이블 로거 클래스 사용을 권장

**주의사항:**
- 컬럼 폭은 들어갈 내용의 최대 터미널 폭보다 크게 설정
- 숫자 데이터는 우측 정렬이 일반적
- 텍스트 데이터는 좌측 정렬이 일반적
- 들여쓰기는 인스턴스 생성 시 지정 (기본값: 2칸)

### 데이터 처리

#### CSV 데이터 저장

- **위치**: `data/raw/` 디렉토리
- **파일명 규칙**:
  - `{TICKER}_max.csv` (전체 기간)
  - `{TICKER}_{START}_{END}.csv` (기간 지정)
  - `{TICKER}_{START}_latest.csv` (시작일만 지정)
  - `{TICKER}_synthetic_max.csv` (합성 데이터)
- **저장 컬럼**: Date, Open, High, Low, Close, Volume
- **가격 컬럼 정밀도**: 소수점 6자리로 라운딩

#### 데이터 정제

- **최근 데이터 제외**: 오늘 기준 2일 전까지만 포함 (Yahoo Finance 데이터 안정성 확보)
- **날짜 형식**: Python `date` 객체로 변환
- **데이터 검증**: 결측치, 0값, 음수값, 급등락 체크

### 백테스트

#### 버퍼존 전략

현재 프로젝트의 핵심 전략은 버퍼존 기반 이동평균 전략입니다.

**기본 개념:**
- 이동평균선 주변에 상하 버퍼존을 설정
- 버퍼존 돌파 시 매매 신호 발생
- 최근 거래 빈도에 따라 파라미터를 동적으로 조정

**매수 조건:**
- 종가가 상단 버퍼존을 상향 돌파
- 유지조건: 돌파 후 일정 기간 밴드 위 유지 (선택적)
- 익일 시가에 진입

**매도 조건:**
- 종가가 하단 버퍼존을 하향 돌파
- 익일 시가에 청산

**동적 조정:**
- 최근 일정 기간 내 매수 횟수를 추적
- 매수 횟수에 비례하여 버퍼존 폭과 유지조건 증가
- 과도한 거래 방지 및 신호 품질 개선

#### 전략 규칙

- **롱 온리**: 매수만 가능, 공매도 불가
- **최대 1 포지션**: 한 번에 하나의 포지션만 보유
- **익일 시가 진입/청산**: 신호 발생 다음 날 시가에 거래 실행
- **거래 비용**: 슬리피지 적용 (수수료 포함)

### 레버리지 ETF 시뮬레이션

기초 자산 데이터로부터 레버리지 ETF를 시뮬레이션하여 합성 데이터를 생성합니다.

#### 시뮬레이션 원리

- **일일 리밸런싱**: 매일 기초 자산의 수익률에 레버리지 배수를 곱하여 가격 계산
- **동적 비용 모델**: 연방기금금리와 스프레드를 기반으로 일일 비용 계산
- **복리 효과**: 일일 수익률을 복리로 누적하여 장기 성과 반영

#### 비용 구조

레버리지 ETF의 비용은 다음 요소로 구성됩니다:
- **펀딩 비용**: (연방기금금리 + 스프레드) × 레버리지 비율
- **운용 비용**: 연간 비용 비율 (expense ratio)
- **일일 비용 환산**: 연간 비용을 영업일 수로 나누어 일일 비용으로 변환

#### 파라미터 최적화

실제 레버리지 ETF 데이터와 비교하여 최적 파라미터를 탐색합니다:
- **2D 그리드 서치**: 펀딩 스프레드와 비용 비율의 조합을 탐색
- **평가 지표**: 누적수익률 상대차이, 일일수익률 RMSE, 가격 차이 등을 종합 평가
- **검증 프로세스**: 겹치는 기간의 데이터로 시뮬레이션 품질 검증

#### 결과 저장

시뮬레이션 결과는 다음 위치에 저장됩니다:
- **합성 데이터**: 생성된 레버리지 ETF 가격 데이터
- **검증 결과**: 최적 파라미터 및 평가 지표
- **일별 비교**: 실제 데이터와 시뮬레이션의 일별 상세 비교

### 시각화

#### 웹 대시보드

Streamlit과 Plotly를 사용하여 레버리지 ETF 시뮬레이션 결과를 인터랙티브하게 시각화합니다.

**주요 기능:**
- 일별 비교 데이터 로딩 및 캐싱
- 인터랙티브 차트 제공 (확대/축소, 범례 토글, 툴팁)
- 요약 지표 메트릭 카드
- 다양한 차트 타입 지원

**차트 종류:**
- **가격 비교 라인 차트**: 실제 종가 vs 시뮬레이션 종가
- **일일수익률 차이 히스토그램**: 차이 분포와 통계 정보
- **누적수익률 차이 라인 차트**: 시간에 따른 누적 차이 추이

**실행 방법:**
웹 대시보드는 별도의 CLI 스크립트로 실행됩니다. 일별 비교 데이터가 사전에 생성되어 있어야 합니다.

**데이터 캐싱:**
대시보드는 데이터 로딩 성능을 위해 Streamlit 캐싱 데코레이터를 사용합니다.

## 개발 철학

QBT 프로젝트는 다음 철학을 따릅니다:

### 1. YAGNI (You Aren't Gonna Need It)

- **사용하지 않는 코드는 미리 만들지 말 것**
- **필요할 때 추가**: 기능은 실제 필요성이 확인된 후에만 구현
- **향후 계획**: 주석으로 임시 처리 가능

### 2. 간결성과 단순성

- **간결한 코드베이스 유지**: 불필요한 추상화 지양
- **명확한 의도**: 복잡한 패턴보다 읽기 쉬운 코드 우선
- **점진적 발전**: 작은 단위로 기능 추가 및 리팩토링

### 3. 확장성

- 도메인별 모듈 분리로 기능 추가 용이
- 새로운 도메인은 `src/qbt/` 아래에 패키지 생성

### 4. 사용자 중심

- 한글 메시지 제공
- 직관적인 CLI 인터페이스
- 명확한 에러 메시지
